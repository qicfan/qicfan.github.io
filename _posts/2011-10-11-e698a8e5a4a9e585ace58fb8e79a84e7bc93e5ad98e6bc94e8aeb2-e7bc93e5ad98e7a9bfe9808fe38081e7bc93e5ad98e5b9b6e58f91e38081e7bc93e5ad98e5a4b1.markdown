---
author: qicfan
comments: true
date: 2011-10-11 06:32:59+00:00
layout: post
slug: '%e6%98%a8%e5%a4%a9%e5%85%ac%e5%8f%b8%e7%9a%84%e7%bc%93%e5%ad%98%e6%bc%94%e8%ae%b2-%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e3%80%81%e7%bc%93%e5%ad%98%e5%b9%b6%e5%8f%91%e3%80%81%e7%bc%93%e5%ad%98%e5%a4%b1'
title: 昨天公司的缓存演讲-缓存穿透、缓存并发、缓存失效
wordpress_id: 279
categories:
- python
tags:
- 缓存
- 缓存失效
- 缓存并发
- 缓存穿透
---

昨天公司研发部架构师给研发部进行了一个简短的培训，主题是缓存问题，主要讲了三点：缓存穿透、缓存并发、缓存实效

一、缓存穿透

我们在项目中使用缓存通常都是APP先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。

这个问题其实经常遇到，只是没有引起足够的重视，在我想来，如果碰到这样的问题可以在封装的缓存SET和GET部分增加个步骤，如果查询一个KEY不存在，就已这个KEY为前缀设定一个标识KEY；以后再查询该KEY的时候，先查询标识KEY，如果标识KEY存在，就返回一个协定好的非FALSH或者NULL值，然后APP做相应的处理，这样缓存层就不会被穿透。当然这个验证KEY的失效时间不能太长。



二、缓存并发

有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。

我现在的想法是再APP中对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。



三、缓存失效

引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置5分钟啊，10分钟这些；并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。

前段时间我在网上也刚好看到了相关的文章，引用其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。



第二、第三个问题其实差不多，主要就时第二个问题时针对同一个缓存，第三个问题时针对很多缓存
